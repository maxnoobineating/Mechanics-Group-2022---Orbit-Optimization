from orb_functions import *
# parameter unload...
# dunno why directly insert as argument will not immediately evaluate

def main(str, vars0):
    vars = {}
    # pr = {}

    elpsM = EM[str].elpsM
    elpsE = EM[str].elpsE
    args = EM[str].args
    fid = EM[str].fid
    verb = EM[str].verb
    maxiter = EM[str].maxiter
    xtol = EM[str].xtol
    gtol = EM[str].gtol
    fM = EM[str].fM
    ubs = EM[str].ubs
    lbs = EM[str].lbs
    periE = EM[str].periE
    periM = EM[str].periM
    #-------------------------------------------#
    # function repackaging
    objectiveA = \
        lambda vars, *args: objA(vars, args, fid=fid)

    objectiveB = \
        lambda vars, *args: objB(vars, args, fid=fid)

    consOMbnd_eq = \
        lambda vars, *args: consOM(vars, args, fid=fid)

    consOEbnd_eq = \
        lambda vars, *args: consOE(vars, args, fid=fid)

    consdeltaV_OptB_ineq = \
        lambda vars, *args: consdeltaV(vars, args, fid=fid)

    # constraint packaging

    con1 = {'type': 'eq', 'fun': consOEbnd_eq, 'args': args}
    con2 = {'type': 'eq', 'fun': consOMbnd_eq, 'args': args}
    conB = {'type': 'ineq', 'fun': consdeltaV_OptB_ineq, 'args': args}

    bnds = opt.Bounds(lb=lbs, ub=ubs, keep_feasible=False)

    nlc_lb = np.linspace(0, 0, fid)
    nlc_ub = np.linspace(Ratio*fM, Ratio*fM, fid)

    nlc = opt.NonlinearConstraint(\
        njit(lambda vars: consThrslim(vars, args, fid))\
        , nlc_lb\
        , nlc_ub)


    # Dictionary constraint 和 NonlinearConstraint Object 可以混用!
    #---- Basinhopping ----#
    # Option A
    consA = [con1, con2, nlc]

    min_keywords = {"method": 'trust-constr'
        , "bounds": bnds
        , "constraints": consA
        , "args": args
        , "options": {'xtol' : xtol
                    , 'maxiter': maxiter
                    , 'verbose': verb}}

    # with cProfile.Profile() as pr['A']:
    solA = basinhopping(objectiveA
                        , vars0.copy()
                        , T = 50
                        , niter = 20
                        , minimizer_kwargs=min_keywords
                        , niter_success=5)
    vars['A'] = solA.x.copy()


    #--------------------------------#
    #---- Basinhopping ----#
    # Option B
    consB = [con1, con2, conB, nlc]

    min_keywords = {"method": 'trust-constr'
        , "bounds": bnds
        , "constraints": consB
        , "args": args
        , "options": {'xtol' : xtol
                    , 'maxiter': maxiter
                    , 'verbose': verb}}

    # with cProfile.Profile() as pr['B']:
    solB = basinhopping(objectiveB
                        , vars0.copy()
                        , T = 50
                        , niter = 20
                        , minimizer_kwargs=min_keywords
                        , niter_success=3)
    vars['B'] = solB.x.copy()

    return vars

# write to file data definition:
# list of dictionaries in jason generated by each sessions
# each session generate:
# {     'description':string
#     , 'vars': any structure containing vars (need clear description)}
import json

file_name = 'OptData.txt'
try:
    with open(file_name, 'x') as nfw:
        nfw.write('[]')
except FileExistsError as err:
    print(err)

with open(file_name, 'r') as fr:
    json_files_IMP = json.load(fr)
js = json_files_IMP.copy()

while True:
    inp = input("read/write? (r/w):")
    if inp == 'r':
        vars = js[-1]['vars']
        varsR = vars['RD-0410']
        varsV = vars['VASIMR']
        break
    elif inp == 'w':
        #-------------------------------------------#
        # "Initial" initial guess
        th0E = 0
        th0M = pi

        r0E = ellipseEq(elps=Earth_Mars.elpsE, fth=th0E-Earth_Mars.periE)
        r0M = ellipseEq(elps=Earth_Mars.elpsM, fth=th0M-Earth_Mars.periM)

        rs0 = np.linspace(r0E, r0M, Earth_Mars.fid)
        # ths0 = np.linspace((pi+periM)/(fid-1), (pi+periM)/(fid-1), fid)
        ths0 = [th0E, th0M]
        cs0 = np.linspace(0.0, 0.0, Earth_Mars.fid-1)
        # vars['init'] = np.concatenate((rs0, cs0, ths0), axis=0)
        # Hohmann transfer inital guess
        vars0 = orbit_interp(np.array([147.0997134 , 216.89938903
                                    , 0.1        , 0.1
                                    , 3.1], np.float64)
                            , Earth_Mars.nfld)

        vars = {}
        pr = {}
        # vars0R = vars0
        # vars0V = vars0
        varsR = []
        varsV = []
        for i in range(5):
            varstmp = main('RD-0410', vars0.copy())
            varsR.append({'A': list(varstmp['A']), 'B': list(varstmp['B'])})
            varstmp = main('VASIMR', vars0.copy())
            varsV.append({'A': list(varstmp['A']), 'B': list(varstmp['B'])})
            # vars0R = varsR[i]['A']
            # vars0V = varsV[i]['A']
            EM['RD-0410'].InitMass += 10e3
            EM['VASIMR'].InitMass += 10e3

        vars['RD-0410'] = varsR
        vars['VASIMR'] = varsV

        js_result = [{
            'description' : '''
        True 33 fid test!!
        ['RD-0410'][0-4]['A'/'B']
        ['VASIMR'][0-4]['A'/'B']
        trajectory v.s. changing initial mass from 10 to 50 tons
        '''
            , 'vars': vars}]

        with open(file_name, 'w') as fw:
            wstr = json.dumps(json_files_IMP+js_result)
            fw.write(wstr)
        break

osRA = list(map(lambda x: to_EosM(x['A'], EM['RD-0410'].args, fid=Earth_Mars.fid), vars['RD-0410']))
osRB = list(map(lambda x: to_EosM(x['B'], EM['RD-0410'].args, fid=Earth_Mars.fid), vars['RD-0410']))
osVA = list(map(lambda x: to_EosM(x['A'], EM['VASIMR'].args, fid=Earth_Mars.fid), vars['VASIMR']))
osVB = list(map(lambda x: to_EosM(x['B'], EM['VASIMR'].args, fid=Earth_Mars.fid), vars['VASIMR']))

dvsRA = list(map(lambda x: dVs(x, EM['RD-0410'].args, fid=Earth_Mars.fid), osRA))
dvsRB = list(map(lambda x: dVs(x, EM['RD-0410'].args, fid=Earth_Mars.fid), osRB))
dvsVA = list(map(lambda x: dVs(x, EM['VASIMR'].args, fid=Earth_Mars.fid), osVA))
dvsVB = list(map(lambda x: dVs(x, EM['VASIMR'].args, fid=Earth_Mars.fid), osVB))

vRA = list(map(sum, dvsRA))
vRB = list(map(sum, dvsRB))
vVA = list(map(sum, dvsVA))
vVB = list(map(sum, dvsVB))

dtsRA = list(map(lambda x: dTs(x, EM['RD-0410'].args, fid=Earth_Mars.fid), osRA))
dtsRB = list(map(lambda x: dTs(x, EM['RD-0410'].args, fid=Earth_Mars.fid), osRB))
dtsVA = list(map(lambda x: dTs(x, EM['VASIMR'].args, fid=Earth_Mars.fid), osVA))
dtsVB = list(map(lambda x: dTs(x, EM['VASIMR'].args, fid=Earth_Mars.fid), osVB))

tRA = list(map(sum, dtsRA))
tRB = list(map(sum, dtsRB))
tVA = list(map(sum, dtsVA))
tVB = list(map(sum, dtsVB))

def payloadRatio(dv, Isp):
    return exp(-dv/Isp)

plrtRA = list(map(lambda x: payloadRatio(x, EM['RD-0410'].Isp), vRA))
plrtVA = list(map(lambda x: payloadRatio(x, EM['VASIMR'].Isp), vVA))


# Plotting
EMorbit=\
[makeplot(ellipse_2d(fidel=128, elps=Earth_Mars.elpsE)\
            , line=':'\
            , label=None\
            , linewidth=1.0)\
,makeplot(ellipse_2d(fidel=128, elps=Earth_Mars.elpsM)\
        , line=':'\
        , label=None\
        , linewidth=1.0)]
red_black5.reverse()
orange_brown5.reverse()
light_darkBlue5.reverse()
light_darkCyan5.reverse()
ziped = zip(map(lambda x: smoothxy(x['A'], EM['RD-0410'].args), varsR), red_black5)
plotsRA = list(map(lambda xy_c: makeplot(xy_c[0], color=xy_c[1], line='-', linewidth=2.0)
                , ziped))
ziped = zip(map(lambda x: smoothxy(x['B'], EM['RD-0410'].args), varsR), orange_brown5)
plotsRB = list(map(lambda xy_c: makeplot(xy_c[0], color=xy_c[1], line='-', linewidth=2.0)
                , ziped))
ziped = zip(map(lambda x: smoothxy(x['A'], EM['VASIMR'].args), varsV), light_darkGreen)
plotsVA = list(map(lambda xy_c: makeplot(xy_c[0], color=xy_c[1], line='-', linewidth=2.0)
                , ziped))
ziped = zip(map(lambda x: smoothxy(x['B'], EM['VASIMR'].args), varsV), light_darkCyan5)
plotsVB = list(map(lambda xy_c: makeplot(xy_c[0], color=xy_c[1], line='-', linewidth=2.0)
                , ziped))

vecfsRA = list(map(lambda vars:
                    (lambda plots, axs, exs: pthstvec([], axs, {'vars': vars['A']
                                                , 'args': EM['RD-0410'].args}))
                , varsR))
vecfsRB = list(map(lambda vars:
                    (lambda plots, axs, exs: pthstvec([], axs, {'vars': vars['B']
                                                , 'args': EM['RD-0410'].args}))
                , varsR))
vecfsVA = list(map(lambda vars:
                    (lambda plots, axs, exs: pthstvec([], axs, {'vars': vars['A']
                                                , 'args': EM['VASIMR'].args}))
                , varsV))
vecfsVB = list(map(lambda vars:
                    (lambda plots, axs, exs: pthstvec([], axs, {'vars': vars['B']
                                                , 'args': EM['VASIMR'].args}))
                , varsV))

def cut(lst):
    return [lst[0], lst[-1]]

# RA
plotall(EMorbit+[plotsRA[0], plotsRA[-1]], cut(vecfsRA), title='RD-0410 Minimum Energy')
# RB
plotall(EMorbit+[plotsRB[0], plotsRB[-1]], cut(vecfsRB), title='RD-0410 Minimum Time')
# VA
plotall(EMorbit+[plotsVA[0], plotsVA[-1]], cut(vecfsVA), title='VASIMR Minimum Energy')
# VB
plotall(EMorbit+[plotsVB[0], plotsVB[-1]], cut(vecfsVB), title='VASIMR Minimum Time')

plotall(EMorbit+[plotsRA[-1], plotsVA[-1]], [vecfsRA[-1], vecfsVA[-1]], title='RD-0410 vs. VASIMR Minimum Energy')
# RB
plotall(EMorbit+[plotsRB[-1]], [vecfsRB[-1]], title='RD-0410 Minimum Time')
# VA
plotall(EMorbit+[plotsVA[-1]], [vecfsVA[-1]], title='VASIMR Minimum Energy')
# VB
plotall(EMorbit+[plotsVB[-1]], [vecfsVB[-1]], title='VASIMR Minimum Time')
